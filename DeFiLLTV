import numpy as np
import streamlit as st
import plotly.graph_objects as go

st.set_page_config(page_title="DeFi Liquidation Feasibility", layout="wide")

# -----------------------------
# Helpers
# -----------------------------


def convex_slippage(beta: np.ndarray, k: float, a: float) -> np.ndarray:
    """Toy convex slippage curve as a function of beta in (0,1).

    beta ~ liquidation_size / executable_depth
    k sets baseline, a sets convexity.
    """
    beta = np.clip(beta, 1e-6, 1 - 1e-6)
    return k + a * (beta ** 2) / (1 - beta)


def stress_multiplier(delta: np.ndarray, s: float) -> np.ndarray:
    """Nonlinear stress amplification."""
    return 1.0 + s * (delta ** 2)


def make_surface(
    nx: int,
    ny: int,
    slippage_k: float,
    slippage_a: float,
    stress_s: float,
    delta_max: float,
    lif_bonus: float,
    lif_bonus_alt: float,
    include_oracle_basis: bool,
    oracle_basis_max: float,
    include_haircut: bool,
    haircut_max: float,
    delta_def: str,
):
    """Generate a 2D feasibility map.

    x-axis: beta (%)
    y-axis: Delta (composite)

    Effective loss = slippage(beta)*stress(delta) + oracle_basis(delta) + haircut(delta)

    Zone labels:
      0 = feasible & profitable (loss <= LIF)
      1 = marginal (loss <= LIF_alt)
      2 = unprofitable
      3 = dislocation (execution failure)
    """
    beta = np.linspace(0.01, 0.99, nx)
    delta = np.linspace(0.0, delta_max, ny)
    B, D = np.meshgrid(beta, delta)

    base = convex_slippage(B, slippage_k, slippage_a)
    amp = stress_multiplier(D, stress_s)

    eff_loss = base * amp

    if include_oracle_basis:
        # Oracle/spot basis grows with stress (scaled to oracle_basis_max)
        eff_loss = eff_loss + oracle_basis_max * (D / delta_max)

    if include_haircut:
        # Liquidity haircut: a fraction of notional that becomes unexecutable, grows with stress
        eff_loss = eff_loss + haircut_max * (D / delta_max) ** 1.2

    # Dislocation boundary: for large beta, even moderate Delta causes pool drain / execution break
    # Purely illustrative.
    dislocation = 0.18 * delta_max + 0.55 * delta_max * (1 / (1 + np.exp(-(B - 0.62) * 22)))
    is_dislocated = D >= dislocation

    # Zones
    zone = np.full_like(eff_loss, 2, dtype=int)
    zone[eff_loss <= lif_bonus_alt] = 1
    zone[eff_loss <= lif_bonus] = 0
    zone[is_dislocated] = 3

    return beta, delta, eff_loss, zone, dislocation


def zone_name(z: int) -> str:
    return {
        0: "Executable & profitable (liquidators act)",
        1: "Marginal (needs higher incentives / perfect execution)",
        2: "Unprofitable (liquidators abstain → bad debt risk)",
        3: "Dislocation (liquidity collapse / execution failure)",
    }.get(z, "Unknown")


# -----------------------------
# Sidebar controls
# -----------------------------

st.title("Liquidation Feasibility in DeFi")

with st.sidebar:
    st.header("Market inputs")

    pool_depth_usd = st.number_input("Executable depth (USD)", min_value=1_000_000, max_value=5_000_000_000, value=200_000_000, step=10_000_000)
    liq_size_usd = st.number_input("Liquidation size (USD)", min_value=100_000, max_value=5_000_000_000, value=50_000_000, step=1_000_000)

    st.divider()
    st.header("Δ definition")
    st.caption("Δ is a composite stress measure used on the y-axis.")

    haircut_pct = st.slider("Liquidity haircut (%)", 0.0, 80.0, 40.0, 1.0)
    oracle_basis_pct = st.slider("Oracle ↔ spot basis (%)", 0.0, 5.0, 1.5, 0.1)

    delta_max = st.slider("Δ max (chart scale)", 5.0, 15.0, 10.0, 0.5)
    w_haircut = st.slider("Weight: haircut in Δ", 0.0, 1.0, 0.7, 0.05)
    w_basis = 1.0 - w_haircut

    st.divider()
    st.header("Liquidation incentives")

    lltv = st.slider("LLTV (%)", 50.0, 95.0, 86.0, 0.5)

    # Convention toggle: In some systems higher LLTV comes with higher bonus; in others it can be capped.
    convention = st.selectbox(
        "LIF convention (for this visualization)",
        ["Higher LLTV → Higher LIF (more incentive)", "Higher LLTV → Lower LIF (less incentive)"],
        index=0,
    )

    # Build a simple mapping to a bonus in [2%, 15%]
    l = lltv / 100.0
    if convention.startswith("Higher LLTV → Higher"):
        lif_bonus = 0.02 + 0.13 * ((l - 0.50) / (0.95 - 0.50))
    else:
        lif_bonus = 0.15 - 0.13 * ((l - 0.50) / (0.95 - 0.50))

    lif_bonus = float(np.clip(lif_bonus, 0.02, 0.15))

    # "High incentive" reference line (alt) for the marginal band
    lif_bonus_alt = min(0.15, lif_bonus + 0.05)

    st.divider()
    st.header("Microstructure model")

    slippage_k = st.slider("Baseline slippage k (%)", 0.0, 5.0, 1.0, 0.1) / 100.0
    slippage_a = st.slider("Convexity a (%)", 1.0, 60.0, 22.0, 1.0) / 100.0
    stress_s = st.slider("Stress amplification s", 0.00, 0.15, 0.06, 0.01)

    show_dislocation = st.checkbox("Show dislocation boundary", value=True)


# -----------------------------
# Derived quantities
# -----------------------------

beta_point = float(min(0.99, max(0.01, liq_size_usd / pool_depth_usd)))

haircut = haircut_pct / 100.0
oracle_basis = oracle_basis_pct / 100.0

# Define Δ as weighted combination scaled to [0, delta_max]
# Here we map haircut and basis into a single delta_point:
# delta_point = delta_max * (w_haircut*haircut_norm + w_basis*basis_norm)
# where haircut_norm in [0,1], basis_norm in [0,1]

haircut_norm = haircut / 0.80 if 0.80 > 0 else 0.0
basis_norm = oracle_basis / 0.05 if 0.05 > 0 else 0.0
haircut_norm = float(np.clip(haircut_norm, 0, 1))
basis_norm = float(np.clip(basis_norm, 0, 1))

delta_point = float(delta_max * (w_haircut * haircut_norm + w_basis * basis_norm))

def effective_loss_for_point(beta_val: float, delta_val: float) -> float:
    base = convex_slippage(np.array([beta_val]), slippage_k, slippage_a)[0]
    amp = stress_multiplier(np.array([delta_val]), stress_s)[0]
    loss = base * amp
    # convert delta back into component contributions approximately
    # we apply max contributions proportional to delta
    loss += (oracle_basis) * (delta_val / delta_max) if delta_max > 0 else 0.0
    loss += (haircut) * (delta_val / delta_max) ** 1.2 if delta_max > 0 else 0.0
    return float(loss)

loss_point = effective_loss_for_point(beta_point, delta_point)

# Status logic
if delta_point >= (0.18 * delta_max + 0.55 * delta_max * (1 / (1 + np.exp(-(beta_point - 0.62) * 22)))):
    z_point = 3
else:
    if loss_point <= lif_bonus:
        z_point = 0
    elif loss_point <= lif_bonus_alt:
        z_point = 1
    else:
        z_point = 2


# -----------------------------
# Build chart
# -----------------------------

beta, delta, eff_loss, zone, disloc = make_surface(
    nx=320,
    ny=260,
    slippage_k=slippage_k,
    slippage_a=slippage_a,
    stress_s=stress_s,
    delta_max=delta_max,
    lif_bonus=lif_bonus,
    lif_bonus_alt=lif_bonus_alt,
    include_oracle_basis=True,
    oracle_basis_max=oracle_basis,
    include_haircut=True,
    haircut_max=haircut,
    delta_def="haircut+basis",
)

X = beta * 100
Y = delta

fig = go.Figure()

# Heatmap zones (discrete)
fig.add_trace(
    go.Heatmap(
        x=X,
        y=Y,
        z=zone,
        zmin=0,
        zmax=3,
        colorbar=dict(
            title="Zone",
            tickvals=[0, 1, 2, 3],
            ticktext=["Profitable", "Marginal", "Unprofitable", "Dislocation"],
        ),
        hovertemplate="β=%{x:.1f}%<br>Δ=%{y:.2f}<br>Zone=%{z}<extra></extra>",
        opacity=0.30,
    )
)

# Contours: effective loss equals LIF thresholds (red)
# Use go.Contour for clean labeling
fig.add_trace(
    go.Contour(
        x=X,
        y=Y,
        z=eff_loss,
        contours=dict(
            start=lif_bonus,
            end=lif_bonus,
            size=1,
            coloring="none",
            showlabels=True,
            labelfont=dict(size=14),
        ),
        line=dict(width=4, color="red"),
        name="LIF threshold",
        hoverinfo="skip",
        showscale=False,
    )
)

fig.add_trace(
    go.Contour(
        x=X,
        y=Y,
        z=eff_loss,
        contours=dict(
            start=lif_bonus_alt,
            end=lif_bonus_alt,
            size=1,
            coloring="none",
            showlabels=True,
            labelfont=dict(size=14),
        ),
        line=dict(width=3, color="red"),
        name="High-incentive threshold",
        hoverinfo="skip",
        showscale=False,
    )
)

# Dislocation boundary
if show_dislocation:
    fig.add_trace(
        go.Scatter(
            x=X,
            y=disloc[:, -1] * 0 + np.nan,  # placeholder
            mode="lines",
            showlegend=False,
        )
    )
    # disloc is a surface; we want boundary line: delta = disloc(beta)
    disloc_line = 0.18 * delta_max + 0.55 * delta_max * (1 / (1 + np.exp(-(beta - 0.62) * 22)))
    fig.add_trace(
        go.Scatter(
            x=X,
            y=disloc_line,
            mode="lines",
            line=dict(width=4, color="black"),
            name="Dislocation boundary",
            hovertemplate="β=%{x:.1f}%<br>Δ=%{y:.2f}<extra></extra>",
        )
    )

# Current point
fig.add_trace(
    go.Scatter(
        x=[beta_point * 100],
        y=[delta_point],
        mode="markers",
        marker=dict(size=16, symbol="x"),
        name="Current scenario",
        hovertemplate=(
            "Current scenario" +
            "<br>β=%{x:.1f}%" +
            "<br>Δ=%{y:.2f}" +
            f"<br>Effective loss={loss_point*100:.1f}%" +
            f"<br>LIF={lif_bonus*100:.1f}%" +
            "<extra></extra>"
        ),
    )
)

# Shaded annotation: "LLTV too high → LIF too low" when the LIF line cuts too far left
# Heuristic: if LIF < 6% and delta can be mid/high, label region to emphasize.
if lif_bonus < 0.06:
    fig.add_annotation(
        x=65,
        y=delta_max * 0.55,
        text="LLTV too high → LIF too low\n(liquidation incentive insufficient under stress)",
        showarrow=False,
        font=dict(size=16),
        bgcolor="rgba(255,255,255,0.65)",
        bordercolor="black",
        borderwidth=1,
    )

fig.update_layout(
    title=dict(
        text="Liquidation feasibility map (x = liquidation size / depth, y = Δ = haircut + oracle basis)",
        x=0.01,
        xanchor="left",
        font=dict(size=20),
    ),
    xaxis=dict(title="Liquidation size / executable depth β (%)", tickfont=dict(size=14), titlefont=dict(size=16)),
    yaxis=dict(title="Δ (haircut + oracle/spot basis)", tickfont=dict(size=14), titlefont=dict(size=16)),
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0.01, font=dict(size=13)),
    height=680,
    margin=dict(l=60, r=40, t=80, b=60),
)


# -----------------------------
# Layout
# -----------------------------

col1, col2 = st.columns([1.4, 1.0], gap="large")

with col1:
    st.plotly_chart(fig, use_container_width=True)

with col2:
    st.subheader("Current scenario")

    st.metric("β (liq size / depth)", f"{beta_point*100:.1f}%")
    st.metric("Δ (composite stress)", f"{delta_point:.2f}")

    st.divider()
    st.metric("Effective liquidation loss", f"{loss_point*100:.1f}%")
    st.metric("Liquidation incentive (LIF)", f"{lif_bonus*100:.1f}%")
    st.metric("LLTV", f"{lltv:.1f}%")

    st.divider()
    st.info(zone_name(z_point))

    st.subheader("How to read")
    st.write(
        "- **x-axis (β)**: liquidation size relative to *executable* market depth (in %).\n"
        "- **y-axis (Δ)**: composite stress proxy built from **liquidity haircut** + **oracle/spot basis**.\n"
        "- **Red contours**: where *effective liquidation loss* equals the liquidation incentive.\n"
        "- If your point sits **above** the red contour → liquidation is **unprofitable** → liquidators abstain → bad debt risk.\n"
        "- **Black boundary**: dislocation region where depth collapses (pool drained / execution failure)."
    )

    st.subheader("DeFi interpretation")
    st.write(
        "**Bad debt** occurs when positions cannot be liquidated fast enough (or at all). In practice, the loss is borne by the **lenders** of the market (or depositors of a curated vault) because the collateral sale does not cover the debt.\n\n"
        "**LLTV vs LTV**: LLTV is the *liquidation threshold* configured per market; LTV is the *current* ratio of debt to collateral value. When **LTV > LLTV**, the position becomes liquidatable.\n\n"
        "**LIF** (liquidation incentive) is the bonus paid to liquidators to compensate for execution risk (slippage, basis, gas/MEV). If the **effective loss** exceeds LIF, rational liquidators will not act."
    )

st.caption("Note: This app uses simplified illustrative functions to visualize the economic constraints behind liquidation. Replace the toy microstructure with real depth curves / historical stress calibration for production underwriting.")
