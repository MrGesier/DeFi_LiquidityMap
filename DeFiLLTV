import numpy as np
import streamlit as st
import plotly.graph_objects as go

# -----------------------------
# Page config
# -----------------------------
st.set_page_config(page_title="Liquidation Feasibility in DeFi", layout="wide")

st.title("Liquidation Feasibility in DeFi")
st.caption(
    "Execution-first risk view: can forced liquidations remain economically executable under stress? "
    "Œî = liquidity haircut + oracle/spot basis. LLTV ‚Üí LIF. If effective loss > LIF ‚áí liquidators abstain ‚áí bad debt risk."
)

# -----------------------------
# Sidebar controls (with tooltips everywhere)
# -----------------------------
st.sidebar.header("Inputs")

x_mode = st.sidebar.radio(
    "X-axis mode",
    ["% of executable depth", "$ (absolute)"],
    help="Choose whether the x-axis is expressed as a percentage of executable depth or in absolute dollars."
)

market_depth_usd = st.sidebar.number_input(
    "Executable market depth ($)",
    min_value=1_000_000,
    max_value=10_000_000_000,
    value=150_000_000,
    step=10_000_000,
    help="Depth that can realistically be hit near spot during liquidation (NOT TVL)."
)

# Liquidity haircut component (part of Œî)
haircut_pct = st.sidebar.slider(
    "Liquidity haircut (%)",
    0, 95, 40,
    help="How much depth disappears under stress due to LP withdrawal / orderbook thinning. "
         "A 40% haircut means only 60% of nominal depth remains executable."
)

# Oracle basis component (part of Œî)
basis_pct = st.sidebar.slider(
    "Oracle ‚Üî spot basis (%)",
    0.0, 15.0, 2.0, step=0.5,
    help="Execution penalty due to oracle lag / divergence. Liquidations trigger at oracle price but execute at spot."
)

# Weights to build Œî from haircut and basis
w_haircut = st.sidebar.slider(
    "Œî weight: haircut",
    0.0, 2.0, 1.0, step=0.05,
    help="Weight applied to the normalized haircut component when building Œî."
)
w_basis = st.sidebar.slider(
    "Œî weight: oracle basis",
    0.0, 2.0, 1.0, step=0.05,
    help="Weight applied to the normalized oracle-basis component when building Œî."
)

# Risk config
lltv = st.sidebar.slider(
    "LLTV (Liquidation Loan-To-Value)",
    0.50, 0.95, 0.86, step=0.01,
    help="Liquidation threshold. When LTV exceeds LLTV, positions become liquidatable. "
         "Higher LLTV increases leverage but reduces liquidation incentive margin."
)

# LIF model selector
lif_model = st.sidebar.selectbox(
    "LIF model (simplified)",
    ["Proxy ( (1-LLTV)/LLTV )", "Fixed bands (5% / 10%)"],
    help="This app focuses on the economic condition: effective execution loss must be ‚â§ liquidation incentive. "
         "Exact formulas vary by protocol; pick a simple proxy or fixed thresholds."
)

# Microstructure / convexity + stress amplification
st.sidebar.header("Execution Model")
base_fee_pct = st.sidebar.slider(
    "Base execution cost (%)",
    0.0, 5.0, 1.0, step=0.1,
    help="Baseline cost floor representing fees + routing friction even for small trades."
)

convexity = st.sidebar.slider(
    "Slippage convexity",
    0.05, 1.00, 0.25, step=0.01,
    help="Controls how fast slippage explodes as liquidation size approaches executable depth."
)

stress_amp = st.sidebar.slider(
    "Stress amplification (non-linear)",
    0.00, 0.20, 0.06, step=0.01,
    help="Controls how strongly Œî amplifies execution loss non-linearly (convex)."
)

# Dislocation boundary parameters
st.sidebar.header("Dislocation Boundary")
disloc_mid = st.sidebar.slider(
    "Dislocation midpoint (Œ≤ at which it starts)",
    0.30, 0.90, 0.60, step=0.01,
    help="Where the dislocation boundary shifts from 'rare' to 'likely' as liquidation size grows."
)
disloc_steep = st.sidebar.slider(
    "Dislocation steepness",
    5, 50, 22, step=1,
    help="How sharp the boundary transition is."
)
disloc_base = st.sidebar.slider(
    "Dislocation base Œî",
    0.5, 5.0, 1.8, step=0.1,
    help="Base Œî threshold below which dislocation is unlikely for small Œ≤."
)
disloc_span = st.sidebar.slider(
    "Dislocation span (additional Œî needed at high Œ≤)",
    0.5, 6.0, 3.8, step=0.1,
    help="How much higher Œî the system can tolerate before dislocating at large Œ≤."
)

# -----------------------------
# Helper functions
# -----------------------------
def lif_from_lltv(lltv_val: float) -> float:
    # Simple proxy: higher LLTV => lower margin
    return max(0.0, (1.0 - lltv_val) / lltv_val)

def effective_loss(beta: np.ndarray, delta: np.ndarray, base_fee: float, conv: float, amp: float) -> np.ndarray:
    """
    Effective liquidation loss (fraction) = convex slippage(beta) amplified by stress(delta) + base fee
    + NOTE: oracle basis already included inside delta definition (not added separately here).
    """
    # convex slippage core
    # grows quickly as beta -> 1
    slip0 = (base_fee) + (conv * (beta**2) / (1.0 - beta))
    # stress amplification (non-linear)
    mult = 1.0 + amp * (delta**2)
    return slip0 * mult

def dislocation_boundary(beta: np.ndarray, mid: float, steep: float, base: float, span: float) -> np.ndarray:
    # logistic transition from base to base+span around mid
    return base + span * (1.0 / (1.0 + np.exp(-(beta - mid) * steep)))

# -----------------------------
# Build Œî from haircut & basis (for the current scenario)
# Normalize haircut to [0,1] via /100, basis to [0,1] via /10
# -----------------------------
delta_current = w_haircut * (haircut_pct / 100.0) * 10.0 + w_basis * (basis_pct / 10.0)
# Scale to ~0..10 range (roughly) by multiplying haircut term by 10 and using basis/10
# This is intentionally a composite "stress index", not a physical unit.

# executable depth under haircut
effective_depth_usd = market_depth_usd * (1.0 - haircut_pct / 100.0)

# current x scenario
if x_mode == "% of executable depth":
    liquidation_size_pct = st.sidebar.slider(
        "Current liquidation size (% of executable depth)",
        1, 100, 50,
        help="Current scenario liquidation size expressed as a percent of executable depth after haircut."
    )
    beta_current = liquidation_size_pct / 100.0
    liquidation_size_usd = effective_depth_usd * beta_current
else:
    liquidation_size_usd = st.sidebar.number_input(
        "Current liquidation size ($)",
        min_value=100_000,
        max_value=float(max(1_000_000, int(effective_depth_usd))),
        value=int(min(50_000_000, max(200_000, effective_depth_usd * 0.5))),
        step=1_000_000,
        help="Current scenario liquidation size in USD. It will be converted into Œ≤ = size/depth."
    )
    beta_current = float(np.clip(liquidation_size_usd / max(1.0, effective_depth_usd), 0.01, 0.99))
    liquidation_size_pct = int(round(beta_current * 100))

# LIF for current
lif_proxy = lif_from_lltv(lltv)
lif_5 = 0.05
lif_10 = 0.10

# choose which LIF we plot as the main red threshold
if lif_model == "Proxy ( (1-LLTV)/LLTV )":
    lif_main = lif_proxy
    lif_label = f"LIF proxy from LLTV ({lif_main*100:.1f}%)"
else:
    # show both 5% and 10% explicitly; use 10% as main line for "more generous"
    lif_main = lif_10
    lif_label = "LIF threshold (10%)"

# -----------------------------
# Grid for plotting
# -----------------------------
beta_grid = np.linspace(0.01, 0.99, 260)
delta_grid = np.linspace(0.0, 10.0, 260)
B, D = np.meshgrid(beta_grid, delta_grid)

loss_grid = effective_loss(B, D, base_fee_pct / 100.0, convexity, stress_amp)

# Zones:
# - Dislocation zone if D >= dislocation boundary
disloc = dislocation_boundary(B, disloc_mid, disloc_steep, disloc_base, disloc_span)
is_disloc = D >= disloc

# - "LLTV too high ‚Üí LIF too low" zone: effective loss > LIF_main (economic no-liquidation)
unsafe_econ = loss_grid > lif_main

# Build zone codes for filled plot:
# 0 = safe (loss <= LIF and not dislocated)
# 1 = marginal band (loss between 5% and 10%) if fixed model, else near LIF (optional)
# 2 = econ-unsafe (loss > LIF) not dislocated
# 3 = dislocation
zone = np.zeros_like(loss_grid, dtype=int)
zone[(unsafe_econ) & (~is_disloc)] = 2
zone[is_disloc] = 3

# If using fixed bands, add marginal band between 5% and 10% for extra readability
if lif_model == "Fixed bands (5% / 10%)":
    zone[(loss_grid > lif_5) & (loss_grid <= lif_10) & (~is_disloc)] = 1
    zone[(loss_grid <= lif_5) & (~is_disloc)] = 0

# -----------------------------
# Plot with Plotly
# -----------------------------
fig = go.Figure()

# Background zones (colors via colorscale)
# Use a discrete colorscale-like mapping through z values; Plotly uses continuous, but this works visually.
fig.add_trace(
    go.Heatmap(
        x=beta_grid * (effective_depth_usd if x_mode == "$ (absolute)" else 100.0),
        y=delta_grid,
        z=zone,
        zmin=0,
        zmax=3,
        showscale=False,
        hovertemplate=(
            ("Liquidation size: $%{x:,.0f}<br>" if x_mode == "$ (absolute)" else "Liquidation size: %{x:.1f}%<br>")
            + "Œî: %{y:.2f}<br>"
            + "Zone: %{z}<extra></extra>"
        ),
        opacity=0.35,
    )
)

# LIF contour(s) in red
if lif_model == "Proxy ( (1-LLTV)/LLTV )":
    levels = [lif_main]
    labels = [lif_label]
else:
    levels = [lif_5, lif_10]
    labels = ["LIF 5%", "LIF 10%"]

for lvl, lbl in zip(levels, labels):
    fig.add_trace(
        go.Contour(
            x=beta_grid * (effective_depth_usd if x_mode == "$ (absolute)" else 100.0),
            y=delta_grid,
            z=loss_grid,
            contours=dict(start=lvl, end=lvl, size=1e-6, coloring="none"),
            line=dict(color="red", width=3),
            showscale=False,
            name=lbl,
            hoverinfo="skip",
        )
    )

# Dislocation boundary in black
fig.add_trace(
    go.Scatter(
        x=beta_grid * (effective_depth_usd if x_mode == "$ (absolute)" else 100.0),
        y=dislocation_boundary(beta_grid, disloc_mid, disloc_steep, disloc_base, disloc_span),
        mode="lines",
        line=dict(color="black", width=3),
        name="Dislocation boundary",
        hovertemplate=(
            ("Liquidation size: $%{x:,.0f}<br>" if x_mode == "$ (absolute)" else "Liquidation size: %{x:.1f}%<br>")
            + "Dislocation Œî: %{y:.2f}<extra></extra>"
        ),
    )
)

# Current scenario point
x_current = liquidation_size_usd if x_mode == "$ (absolute)" else (beta_current * 100.0)
loss_current = float(effective_loss(np.array([beta_current]), np.array([delta_current]),
                                    base_fee_pct / 100.0, convexity, stress_amp)[0])

fig.add_trace(
    go.Scatter(
        x=[x_current],
        y=[delta_current],
        mode="markers",
        marker=dict(size=14, symbol="x"),
        name="Current scenario",
        hovertemplate=(
            (f"Liquidation size: ${liquidation_size_usd:,.0f}<br>" if x_mode == "$ (absolute)" else f"Liquidation size: {beta_current*100:.1f}%<br>")
            + f"Œî: {delta_current:.2f}<br>"
            + f"Effective loss: {loss_current*100:.1f}%<br>"
            + (f"LIF (from LLTV): {lif_main*100:.1f}%<extra></extra>" if lif_model.startswith("Proxy") else f"LIF band: {('5%/10%')}<extra></extra>")
        ),
    )
)

# Layout
x_title = "Liquidation size / executable depth ($)" if x_mode == "$ (absolute)" else "Liquidation size / depth (%)"
fig.update_layout(
    height=680,
    margin=dict(l=20, r=20, t=60, b=20),
    title="Liquidation Feasibility Map (Execution Loss vs Incentives & Dislocation)",
    xaxis_title=x_title,
    yaxis_title="Œî = liquidity haircut + oracle/spot basis (stress index)",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
)

# Zone labels (annotations)
fig.add_annotation(x=0.02, y=0.98, xref="paper", yref="paper",
                   text="<b>Zones:</b> Safe / Marginal / LLTV too high ‚Üí LIF too low / Dislocation",
                   showarrow=False, align="left")

st.plotly_chart(fig, use_container_width=True)

# -----------------------------
# Current Scenario (below the graph)
# -----------------------------
st.subheader("Current Scenario (below the graph)")

c1, c2, c3, c4 = st.columns(4)

c1.metric("Executable depth ($)", f"${effective_depth_usd:,.0f}")
c2.metric("Liquidation size ($)", f"${liquidation_size_usd:,.0f}")
c3.metric("Œî (stress index)", f"{delta_current:.2f}")
if lif_model.startswith("Proxy"):
    c4.metric("LIF (from LLTV)", f"{lif_main*100:.1f}%")
else:
    c4.metric("LIF reference", "5% / 10%")

st.markdown("---")

left, right = st.columns([1, 1])

with left:
    st.markdown("### Execution economics")
    st.write(f"- **Effective liquidation loss** (slippage+stress): **{loss_current*100:.1f}%**")
    if lif_model.startswith("Proxy"):
        st.write(f"- **Liquidation incentive (LIF)** from LLTV: **{lif_main*100:.1f}%**")
    else:
        st.write(f"- **Liquidation incentive reference bands:** 5% / 10%")
    st.write(
        "- Rule: if **effective loss > LIF**, liquidation is economically irrational ‚Üí liquidators abstain ‚Üí bad debt risk."
    )

with right:
    st.markdown("### Risk verdict")
    disloc_current = float(dislocation_boundary(np.array([beta_current]), disloc_mid, disloc_steep, disloc_base, disloc_span)[0])
    if delta_current >= disloc_current:
        st.error("üõë **Dislocation regime**: liquidity collapse likely (pool drained / execution failure).")
    elif loss_current > lif_main:
        st.error("‚ö†Ô∏è **LLTV too high ‚Üí LIF too low**: effective loss exceeds incentive ‚Üí liquidation may not happen ‚Üí bad debt risk.")
    else:
        st.success("‚úÖ **Economically feasible**: incentive exceeds effective stressed execution loss.")

st.markdown("---")
with st.expander("Notes (what this is / is not)"):
    st.write(
        "This is an execution-feasibility visualization. Œî is a composite stress index "
        "built from liquidity haircut and oracle/spot basis (with adjustable weights). "
        "The slippage function is intentionally convex to reflect real-world depth decay. "
        "You can tune convexity and stress amplification to fit your intuition or data."
    )
