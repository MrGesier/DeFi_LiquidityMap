import numpy as np
import streamlit as st
import plotly.graph_objects as go

# =============================
# Page config
# =============================
st.set_page_config(page_title="Liquidation Feasibility in DeFi", layout="wide")

st.title("Liquidation Feasibility in DeFi")
st.caption(
    "Execution-first risk view: can forced liquidations remain economically executable under stress? "
    "Œî = liquidity haircut + oracle/spot basis. LLTV ‚Üí LIF. If effective loss > LIF ‚áí liquidators abstain ‚áí bad debt risk."
)

# =============================
# Sidebar layout
# =============================
st.sidebar.title("Controls")

x_mode = st.sidebar.radio(
    "X-axis mode",
    ["% of executable depth", "$ (absolute)"],
    help="Switch x-axis units. In $ mode, liquidation size is converted into Œ≤ = size/depth."
)

# -----------------------------
# Category: Market Depth
# -----------------------------
st.sidebar.subheader("Market Depth")

market_depth_usd = st.sidebar.number_input(
    "Executable market depth ($)",
    min_value=1_000_000,
    max_value=10_000_000_000,
    value=150_000_000,
    step=10_000_000,
    help="Depth that can realistically be hit near spot during liquidation (NOT TVL). "
         "Think: executable depth within a small price band / limited blocks."
)

# -----------------------------
# Category: Stress & Œî components
# -----------------------------
st.sidebar.subheader("Stress Components (Œî)")

haircut_pct = st.sidebar.slider(
    "Liquidity haircut (%)",
    0, 95, 40,
    help="Represents LP withdrawal / depth collapse under stress. "
         "A 40% haircut means only 60% of nominal depth remains executable."
)

basis_pct = st.sidebar.slider(
    "Oracle ‚Üî spot basis (%)",
    0.0, 15.0, 2.0, step=0.5,
    help="Penalty due to oracle lag/divergence. Liquidations trigger at oracle price but execute at spot."
)

st.sidebar.markdown("**Œî weights**")
w_haircut = st.sidebar.slider(
    "Weight: haircut",
    0.0, 2.0, 1.0, step=0.05,
    help="Weight applied to normalized haircut when constructing Œî."
)

w_basis = st.sidebar.slider(
    "Weight: basis",
    0.0, 2.0, 1.0, step=0.05,
    help="Weight applied to normalized oracle basis when constructing Œî."
)

# -----------------------------
# Category: LLTV / LIF
# -----------------------------
st.sidebar.subheader("Risk Config (LLTV ‚Üí LIF)")

lltv = st.sidebar.slider(
    "LLTV (Liquidation Loan-To-Value)",
    0.50, 0.95, 0.86, step=0.01,
    help="Liquidation threshold. When LTV exceeds LLTV, the position becomes liquidatable. "
         "Higher LLTV increases leverage but typically reduces liquidation margin."
)

lif_model = st.sidebar.selectbox(
    "LIF model",
    ["Proxy ( (1-LLTV)/LLTV )", "Fixed bands (5% / 10%)"],
    help="We focus on the economic condition: effective execution loss must be ‚â§ liquidation incentive (LIF). "
         "Exact protocol formulas vary; pick a simple proxy or fixed bands for illustration."
)

# -----------------------------
# Category: Microstructure (slippage shape)
# -----------------------------
st.sidebar.subheader("Microstructure (Execution Cost)")

base_fee_pct = st.sidebar.slider(
    "Base execution cost (%)",
    0.0, 5.0, 1.0, step=0.1,
    help="Baseline cost floor (fees + routing friction), even for small liquidations."
)

convexity = st.sidebar.slider(
    "Slippage convexity",
    0.05, 1.00, 0.25, step=0.01,
    help="Controls how fast slippage explodes as liquidation size approaches executable depth (Œ≤‚Üí1)."
)

stress_amp = st.sidebar.slider(
    "Stress amplification (non-linear)",
    0.00, 0.20, 0.06, step=0.01,
    help="Controls how strongly Œî amplifies execution costs non-linearly."
)

# -----------------------------
# Category: Dislocation boundary
# -----------------------------
st.sidebar.subheader("Dislocation Boundary")

disloc_mid = st.sidebar.slider(
    "Midpoint (Œ≤ where dislocation starts)",
    0.30, 0.90, 0.60, step=0.01,
    help="Where the dislocation boundary transitions as Œ≤ increases."
)

disloc_steep = st.sidebar.slider(
    "Steepness",
    5, 50, 22, step=1,
    help="How sharp the dislocation boundary transition is."
)

disloc_base = st.sidebar.slider(
    "Base Œî",
    0.5, 5.0, 1.8, step=0.1,
    help="Baseline Œî threshold below which dislocation is unlikely for small Œ≤."
)

disloc_span = st.sidebar.slider(
    "Additional Œî tolerance at high Œ≤",
    0.5, 6.0, 3.8, step=0.1,
    help="How much additional Œî can be tolerated before dislocation at large Œ≤."
)

# =============================
# Helper functions
# =============================
def lif_from_lltv(lltv_val: float) -> float:
    # Simple proxy: higher LLTV -> lower margin.
    return max(0.0, (1.0 - lltv_val) / lltv_val)

def effective_loss(beta: np.ndarray, delta: np.ndarray, base_fee: float, conv: float, amp: float) -> np.ndarray:
    """
    Effective liquidation loss (fraction):
    - convex slippage in beta
    - amplified by stress delta
    Note: oracle basis is included inside delta construction (conceptually).
    """
    slip0 = base_fee + (conv * (beta**2) / (1.0 - beta))
    mult = 1.0 + amp * (delta**2)
    return slip0 * mult

def dislocation_boundary(beta: np.ndarray, mid: float, steep: float, base: float, span: float) -> np.ndarray:
    return base + span * (1.0 / (1.0 + np.exp(-(beta - mid) * steep)))

# =============================
# Build Œî (y-axis)
# =============================
# Normalize haircut to [0..1] via /100, basis to [0..~1.5] via /10 (since basis slider 0..15)
# Then map to a 0..10-ish stress index.
delta_current = (w_haircut * (haircut_pct / 100.0) * 10.0) + (w_basis * (basis_pct / 10.0))

# Depth after haircut
effective_depth_usd = market_depth_usd * (1.0 - haircut_pct / 100.0)

# =============================
# Current scenario (x-axis)
# =============================
if x_mode == "% of executable depth":
    liquidation_size_pct = st.sidebar.slider(
        "Current liquidation size (% of executable depth)",
        1, 100, 50,
        help="Current scenario liquidation size as a percent of executable depth (after haircut)."
    )
    beta_current = liquidation_size_pct / 100.0
    liquidation_size_usd = effective_depth_usd * beta_current

else:
    # IMPORTANT: keep all number_input args the same type (int) to avoid StreamlitMixedNumericTypesError
    max_liq = int(max(100_000, np.floor(effective_depth_usd)))  # int
    default_liq = int(min(50_000_000, max(200_000, max_liq * 0.5)))  # int
    step_liq = int(max(100_000, min(5_000_000, max_liq // 20)))  # int

    liquidation_size_usd = st.sidebar.number_input(
        "Current liquidation size ($)",
        min_value=int(100_000),
        max_value=int(max_liq),
        value=int(default_liq),
        step=int(step_liq),
        help="Current scenario liquidation size in USD. Converted internally to Œ≤ = size/depth."
    )
    beta_current = float(np.clip(liquidation_size_usd / max(1.0, effective_depth_usd), 0.01, 0.99))
    liquidation_size_pct = int(round(beta_current * 100))

# =============================
# LIF setup
# =============================
lif_proxy = lif_from_lltv(lltv)
lif_5 = 0.05
lif_10 = 0.10

if lif_model == "Proxy ( (1-LLTV)/LLTV )":
    lif_lines = [(lif_proxy, f"LIF from LLTV ({lif_proxy*100:.1f}%)")]
    lif_main = lif_proxy
else:
    lif_lines = [(lif_5, "LIF 5%"), (lif_10, "LIF 10%")]
    lif_main = lif_10  # use 10% as "more generous" main reference

# =============================
# Build grid
# =============================
beta_grid = np.linspace(0.01, 0.99, 280)
delta_grid = np.linspace(0.0, 10.0, 280)
B, D = np.meshgrid(beta_grid, delta_grid)

loss_grid = effective_loss(B, D, base_fee_pct / 100.0, convexity, stress_amp)
disloc_grid = dislocation_boundary(B, disloc_mid, disloc_steep, disloc_base, disloc_span)

is_disloc = D >= disloc_grid
unsafe_econ = loss_grid > lif_main

# zone codes:
# 0 safe
# 1 marginal (only if fixed bands)
# 2 econ-unsafe (LLTV too high ‚Üí LIF too low)
# 3 dislocation
zone = np.zeros_like(loss_grid, dtype=int)
zone[(unsafe_econ) & (~is_disloc)] = 2
zone[is_disloc] = 3

if lif_model == "Fixed bands (5% / 10%)":
    zone[(loss_grid > lif_5) & (loss_grid <= lif_10) & (~is_disloc)] = 1
    zone[(loss_grid <= lif_5) & (~is_disloc)] = 0

zone_label = {
    0: "SAFE (liquidators act)",
    1: "MARGINAL (sensitive to incentives)",
    2: "LLTV too high ‚Üí LIF too low (liquidators abstain)",
    3: "DISLOCATION (liquidity collapse / execution failure)",
}

# x axis values for plotting
if x_mode == "$ (absolute)":
    x_grid = beta_grid * effective_depth_usd
    x_current = float(liquidation_size_usd)
    x_title = "Liquidation size / executable depth ($)"
else:
    x_grid = beta_grid * 100.0
    x_current = float(beta_current * 100.0)
    x_title = "Liquidation size / executable depth (%)"

# =============================
# Plotly Figure
# =============================
fig = go.Figure()

# Discrete colorscale for zones (explicit => heatmap always visible)
# 0 safe, 1 marginal, 2 econ-unsafe, 3 dislocation
colorscale = [
    [0.00, "#C8F7C5"], [0.2499, "#C8F7C5"],  # safe
    [0.25, "#FFF3B0"], [0.4999, "#FFF3B0"],  # marginal
    [0.50, "#FFD1D1"], [0.7499, "#FFD1D1"],  # econ-unsafe
    [0.75, "#D6E4FF"], [1.00, "#D6E4FF"],    # dislocation
]

# Heatmap (zones)
fig.add_trace(
    go.Heatmap(
        x=x_grid,
        y=delta_grid,
        z=zone,
        zmin=0,
        zmax=3,
        colorscale=colorscale,
        opacity=0.55,
        colorbar=dict(
            title="Zone",
            tickmode="array",
            tickvals=[0, 1, 2, 3],
            ticktext=[
                "Safe",
                "Marginal",
                "LLTV too high ‚Üí LIF too low",
                "Dislocation",
            ],
        ),
        hovertemplate=(
            ("Liquidation size: $%{x:,.0f}<br>" if x_mode == "$ (absolute)" else "Liquidation size: %{x:.1f}%<br>")
            + "Œî: %{y:.2f}<br>"
            + "Zone: %{z}<extra></extra>"
        ),
    )
)

# LIF contour lines (red)
for lvl, lbl in lif_lines:
    fig.add_trace(
        go.Contour(
            x=x_grid,
            y=delta_grid,
            z=loss_grid,
            contours=dict(start=lvl, end=lvl, size=1e-6, coloring="none"),
            line=dict(color="red", width=3),
            showscale=False,
            name=lbl,
            hoverinfo="skip",
        )
    )

# Dislocation boundary line (black)
fig.add_trace(
    go.Scatter(
        x=x_grid,
        y=dislocation_boundary(beta_grid, disloc_mid, disloc_steep, disloc_base, disloc_span),
        mode="lines",
        line=dict(color="black", width=3),
        name="Dislocation boundary",
        hovertemplate=(
            ("Liquidation size: $%{x:,.0f}<br>" if x_mode == "$ (absolute)" else "Liquidation size: %{x:.1f}%<br>")
            + "Dislocation Œî: %{y:.2f}<extra></extra>"
        ),
    )
)

# Current scenario point
loss_current = float(
    effective_loss(
        np.array([beta_current]),
        np.array([delta_current]),
        base_fee_pct / 100.0,
        convexity,
        stress_amp
    )[0]
)

fig.add_trace(
    go.Scatter(
        x=[x_current],
        y=[delta_current],
        mode="markers",
        marker=dict(size=14, symbol="x", color="black"),
        name="Current scenario",
        hovertemplate=(
            (f"Liquidation size: ${liquidation_size_usd:,.0f}<br>" if x_mode == "$ (absolute)" else f"Liquidation size: {beta_current*100:.1f}%<br>")
            + f"Œî: {delta_current:.2f}<br>"
            + f"Effective loss: {loss_current*100:.1f}%<br>"
            + (f"LIF: {lif_proxy*100:.1f}% (from LLTV)<extra></extra>"
               if lif_model.startswith("Proxy") else "LIF: 5% / 10% bands<extra></extra>")
        ),
    )
)

fig.update_layout(
    height=720,
    title="Liquidation Feasibility Map (zones, incentives & dislocation)",
    xaxis_title=x_title,
    yaxis_title="Œî = liquidity haircut + oracle/spot basis (stress index)",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=20, r=20, t=60, b=20),
)

# Extra annotations (zone meaning)
fig.add_annotation(
    x=0.01, y=0.99, xref="paper", yref="paper",
    text=(
        "<b>Key rule:</b> if <b>effective loss</b> crosses the <b>red LIF line</b>, "
        "liquidation becomes irrational ‚Üí liquidators abstain ‚Üí bad debt risk."
    ),
    showarrow=False,
    align="left",
)

st.plotly_chart(fig, use_container_width=True)

# =============================
# Current Scenario (below the graph)
# =============================
st.subheader("Current Scenario (below the graph)")

c1, c2, c3, c4 = st.columns(4)
c1.metric("Executable depth after haircut ($)", f"${effective_depth_usd:,.0f}")
c2.metric("Liquidation size ($)", f"${liquidation_size_usd:,.0f}")
c3.metric("Œî (stress index)", f"{delta_current:.2f}")
if lif_model.startswith("Proxy"):
    c4.metric("LIF (from LLTV)", f"{lif_proxy*100:.1f}%")
else:
    c4.metric("LIF reference", "5% / 10%")

st.markdown("---")

# Verdict logic
disloc_current = float(
    dislocation_boundary(np.array([beta_current]), disloc_mid, disloc_steep, disloc_base, disloc_span)[0]
)

if delta_current >= disloc_current:
    st.error("üõë **Dislocation regime**: liquidity collapse likely (pool drained / execution failure).")
elif loss_current > lif_main:
    st.error("‚ö†Ô∏è **LLTV too high ‚Üí LIF too low**: effective loss exceeds incentive ‚Üí liquidation may not happen ‚Üí bad debt risk.")
else:
    st.success("‚úÖ **Economically feasible**: incentive exceeds effective stressed execution loss.")

with st.expander("How to interpret"):
    st.write(
        "‚Ä¢ **Green**: liquidation profitable ‚Üí liquidators act.\n"
        "‚Ä¢ **Yellow**: marginal ‚Üí depends on incentives & assumptions.\n"
        "‚Ä¢ **Pink**: **LLTV too high ‚Üí LIF too low** ‚Üí liquidators abstain ‚Üí bad debt risk.\n"
        "‚Ä¢ **Blue**: dislocation ‚Üí liquidity collapse / execution failure.\n\n"
        "Œî is a composite stress index built from liquidity haircut and oracle/spot basis (weights adjustable). "
        "The execution loss model is intentionally convex to reflect real-world depth decay."
    )
